Consider a refactoring that replaces an array containing position given by a latitude and longitude as in fig.~\ref{refa:ReplaceArray-before} with an object that gives read or write access to the same values through setters and getters that make it immediately clear what is being accessed as seen in fig.~\ref{refa:ReplaceArray-after}.

For this to be a refactoring we must be certain that indexing can only occur in bounds for the original program as there will be no corresponding out of bounds failure for method calls. There may be usage sites in the original program which in some way rely on the array representation, these must be identified and handled in an equivalent way in the refactored program.

\begin{figure}
  \begin{subfigure}[h]{.45\linewidth} 
    \lstinputlisting[style=smallJava]{ReplaceArrayWithObject/Java/before.java}
    \caption{Before}
    \label{refa:ReplaceArray-before}   
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[h]{.45\linewidth}
    \lstinputlisting[style=smallJava]{ReplaceArrayWithObject/Java/after.java}
    \caption{After}
    \label{refa:ReplaceArray-after}
  \end{subfigure}
  \caption{Replace array with object refactoring}
  \label{refa:ReplaceArray}
\end{figure}

In REFINITY it would be difficult to even model this because what we would most naturally want to do is to somehow write a LHS with an abstract statement $P$ and a RHS with an abstract statemetn $Q$ and specify that $P$ contains an array used to index some data as seen in fig.~\ref{refa:ReplaceArray}. Then we would want to require somehow that $Q$ is exactly as $P$ but with the array substituted for a data object and any reads or writes to the array replaced with appropriate setters and getters. Such things are not possible as on the modeling level the abstract elements operate as black boxes we can't whose contents we can't specify. 
