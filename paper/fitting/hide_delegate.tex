\subsection{Encoding the Hide Delegate refactoring}\label{sec:hideDelegate}

The \rname{Hide Delegate} refactoring can be described as an \rname{Extract Method} refactoring on a call chain such as seen in \jcode{Y y = o.f().g()}
where the call chain is extracted to a new method on \jcode{o}, say \jcode{h()} which contains the extraction \jcode{Y h() \{ return this.f().g(); \}}, such that we replace the chain as seen in \jcode{Y y = o.h()}.

\begin{figure}[tbp]
  \centering
  \begin{subfigure}{.3\linewidth}
    \input{tikz/hd-npe-before}
    \caption{Before}
    \label{fig:hd-npe-before}
  \end{subfigure}
  \begin{subfigure}{.3\linewidth}
    \input{tikz/hd-npe-after}
    \caption{After}
    \label{fig:hd-npe-after}    
  \end{subfigure}
  \caption{NPEs}
  \label{fig:NPEs}
\end{figure}

We note that a pattern usually considered is also \jcode{X x = o.f(); Y y = x.g()} potentially with non-interfering intermediate statements inbetween the two statements,
but in that case we can reach the considered pattern through applications of \rname{Slide Statement} and finally \rname{Inline Variable} on \jcode{x}.
The refactoring can enable less coupling as the class that contained the call chain afterwards does not need to know the return type of \jcode{f()}.

Also of note is the scenario shown in Fig.~\ref{fig:NPEs} where the call to \jcode{f()} returns \jcode{null}. In the strictest sense of behavioral preservation
we will observe a difference as the \jcode{NullPointerException} (NPE) thrown before Fig.~\ref{fig:hd-npe-before} will show a different stacktrace than the one thrown after Fig.~\ref{fig:hd-npe-before}.
Thus we consider a behavioral equivalence that allows for disagreement in stacktraces for such matching exceptions; in fact one is unable to make any other distinction in \Refinity{}.

%\vsnote{Three things on the nature of encoding things in R.: i) this is an example that R. is bad at \textit{names}: we need concrete names \texttt{f/g} (with concrete parameters), but want placeholders. ii) we don't really remove/replace anything, since we need all the code that we want to use in the same class, i.e., the ``new'' method \jcode{hideDelegate()} was already present before -- but that's okay because it's obviously correct to introduce methods that are not called -- another example of syntactical requirements on encodings in R. iii) This is the example for our abuse of R.\ for OO-based refactorings.}
%\vsnote{TODO @Ole: check that in HD we explain the ``equivalence'' of the NPEs --- I don't see this yet in the example in 3.1}

\begin{figure}[tbp]
  \captionsetup{type=lstlisting}
  \centering
  \begin{sublstlisting}[b]{.455\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/before.refinity}
    \caption{Before}
    \label{lst:HideDelegate-nofields-before-refinity}
  \end{sublstlisting}\hspace{1cm}
  \begin{sublstlisting}[b]{.455\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/after.refinity}
    \caption{After}
    \label{lst:HideDelegate-nofields-after-refinity}
  \end{sublstlisting}
\caption{Hide Delegate in REFINITY}
\label{lst:HideDelegate-nofields-refinity}
\end{figure}

\begin{figure}[tbp]
  \captionsetup{type=lstlisting}
  \centering
  \begin{sublstlisting}[b]{.4\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/Resource.refinity}
    \caption{Before}
    \label{lst:HideDelegate-nofields-resource-refinity}
  \end{sublstlisting}\hspace{1cm}
  \begin{sublstlisting}[b]{.4\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/Owner.refinity}
    \caption{After}
    \label{lst:HideDelegate-nofields-owner-refinity}
  \end{sublstlisting}
\caption{Hide Delegate Classes in REFINITY}
\label{lst:HideDelegate-nofields-classes-refinity}
\end{figure}
We specify the Before and After program fragment for a \rname{Hide Delegate} refactoring in Listing~\ref{lst:HideDelegate-nofields-refinity} which contains no surprises when compared to the sketched out example above.
The classes and methods used in the refactoring appear in Listing~\ref{lst:HideDelegate-nofields-classes-refinity} and show that we minimally specify the contents of the involved methods by using abstract
statements in their bodies.
Note that we do not require that the abstract statements \rcode{F} and \rcode{G} in the methods \rcode{getOwner()} and \rcode{getResource} cannot complete abruptly.
That means the abstract statements may for instance throw exceptions; for instance the sketched out scenario considered in Fig.~\ref{fig:NPEs} where here \rcode{getResource()} will return \rcode{null} and cause the following call to throw a NPE is a possibility.

In order to prove the specified \rname{Hide Delegate} refactoring in the published version of \Refinity{} one must write a postcondition that consists of a conjunction of return values of the before and after programs being identical and
that exceptions thrown are both instances of NPE or equal.
This is owing to the fact that \Refinity{} does not consider occurances of \jcode{new NullPointerException()}, or any other newly created objects, to be equal.

In our modified version of \Refinity{} this is no longer an issue and we may use the default postcondition that simply matches return results and exceptions;
\Refinity{} will automatically manage prove the shown \rname{Hide Delegate} refactoring to be correct wrt. the given postconditions.


%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: "../main"
%%% End:
