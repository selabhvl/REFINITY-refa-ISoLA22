\subsection{Encoding the Hide Delegate refactoring}\label{sec:hideDelegate}

The Hide Delegate refactoring can be described as an Extract Method refactoring on a call chain such as \jcode{Y y = o.f().g()}
the call chain is extracted to a method on \jcode{o} such that we can replace the chain with a call to the new method \jcode{o.h()}
which we declare as \jcode{Y h() \{ return this.f().g(); \}}.

The refactoring can enable less coupling as the class that contained the call chain afterwards does not need to know the return type of \jcode{f()}.
We note that this is just one example and intermediate, dotted, expressions can be arbitrary long and/or broken up across assignments to local variables.

%\vsnote{Q: Generalize to \jcode{o = AE; z = o.g(); return z;} ?}
%\vsnote{Three things on the nature of encoding things in R.: i) this is an example that R. is bad at \textit{names}: we need concrete names \texttt{f/g} (with concrete parameters), but want placeholders. ii) we don't really remove/replace anything, since we need all the code that we want to use in the same class, i.e., the ``new'' method \jcode{hideDelegate()} was already present before -- but that's okay because it's obviously correct to introduce methods that are not called -- another example of syntactical requirements on encodings in R. iii) This is the example for our abuse of R.\ for OO-based refactorings.}


\begin{figure}
  \centering
  \begin{subfigure}[b]{.455\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/before.refinity}
    \caption{Before}
    \label{lst:HideDelegate-nofields-before-refinity}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[b]{.455\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/after.refinity}
    \caption{After}
    \label{lst:HideDelegate-nofields-after-refinity}
  \end{subfigure}
\captionof{lstlisting}{Hide Delegate}
\label{lst:HideDelegate-nofields-refinity}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}[b]{.4\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/Resource.refinity}
    \caption{Before}
    \label{lst:HideDelegate-nofields-resource-refinity}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[b]{.4\linewidth}
    \lstinputlisting[style=refinity]{HideDelegate/REFINITY/Owner.refinity}
    \caption{After}
    \label{lst:HideDelegate-nofields-owner-refinity}
  \end{subfigure}
\captionof{lstlisting}{Hide Delegate Classes}
\label{lst:HideDelegate-nofields-classes-refinity}
\end{figure}
We specify the Before and After program fragment for a Hide Delegate refactoring in Listing~\ref{lst:HideDelegate-nofields-refinity} which contains no surprises when compared to the sketched out example above.
The classes and methods used in the refactoring appear in Listing~\ref{lst:HideDelegate-nofields-classes-refinity} and show that we minimally specify the contents of the involved methods by using abstract
statements in their bodies.
Note that we do not require that the abstract statements \rcode{F} and \rcode{G} in the methods \rcode{getOwner()} and \rcode{getResource} cannot complete abruptly.
That means the abstract statements may for instance throw exceptions.
In the published version of \Refinity{} one must write a postcondition that consists of a conjunction of return values of the sides being identical and
that exceptions thrown are both instances of \jcode{NullPointerException} or equal.
This is owing to the fact that \Refinity{} did not consider occurances of \jcode{new NullPointerException()} originating from \oanote{fix this phrasing}{the same place} to be identical.
In our modified version this is no longer an issue and we may use the default postcondition that simply matches return results and exceptions.





% \subsection*{Hide Delegate --- once more with fields}

% Similarily a minor variation of the  Hide Delegate refactoring also applies to a call chain which assigns to fields
% e.g. \jcode{x = o.f(); Y y = x.g()}.


%TODO this is not yet done

%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: "../main"
%%% End:
