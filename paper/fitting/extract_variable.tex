Let us consider the Extract Local Variable refactoring seen in Listing~\ref{lst:ExtractVariable-java}.
The example is an instance of a more general case, where preserving the behaviour of the program depends on other parts of the code.
The behaviour of the program changes if the method call \jcode{n()} has access to the attribute \jcode{x} and overwrites it.

Before we would have calls to \jmcode{o$_1$.n()} and then \jmcode{o$_2$.n()} whereas after applying the refactoring we would
have \jmcode{o$_1$.n()} followed by \jmcode{o$_1$.n()}. In this case if e.g. \jcode{n()} simply prints \jcode{this.toString()} we will
observe a difference in the two programs.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{.2\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/before.java}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}{.3\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/after.java}
    \caption{After}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-java}
\end{figure}

The dynamic check for such a change detailed in other work~\ref{stolz:isolarefa} codified the necessity that the reference \jcode{x}
remains unchanged through the introduction of an assertion \jcode{assert temp == x;} to uncover violations after the fact,
which is useful e.g. when checking the refactored code against its suite of unit tests.

In REFINITY one proceeds to verify a refactoring as correct by supplying the code before and after refactoring and supplying a desired precondition and postcondition to relate
the two programs. One essentially asks REFINITY: Given these preconditions does the postcondition hold after abstract execution of these two programs? REFINITY accepts a restricted
subset of Java, the same restrictions present in KeY, with extensions for abstract program fragments; pieces that are ``placeholders'' for concrete Java code.
The specification facilities for either Java constructs or abstact program fragments are described in the Java Modelling Language (JML) with some extensions.

We describe the refactoring to REFINITY as shown with a left side (Before) in Listing~\ref{lst:ExtractVariable-refinity-before},
a right side (After) in Listing~\ref{lst:ExtractVariable-refinity-after} and a method level context (Method) in Listing~\ref{lst:ExtractVariable-refinity-method}.

Additionally some information is declared in parts of REFINITY's interface that are not shown here:
Free program variables, here \rcode{x}; abstract location sets, here \rcode{frN} and \rcode{fpN}; relevant locations for the before and after code, here empty;
the desired precondition, here empty, and the desired postcondition.

The pre- and postcondition are specified in terms of equations that may relate the effects of the before and after side such as return values, exceptions thrown and any
of the relevant locations declared.
In our case we simply specify the postcondition that \rcode{x} returned in Before must be identical to \rcode{temp} returned in After and that any exception thrown must be identical for the two sides.

What can be seen in the first three lines of the Before and After sides is an \emph{abstract execution constraint} on \rcode{x}.
Namely that \rcode{x} should be disjoint from the abstract location set \rcode{frN}.

While inspecting the method \rcode{n()} you will discover an \emph{Abstract Statement} (AS) \rcode{\\abstract\_statement S;} immediately trailing the assignable and accessible specification for it.
This reprecent a ``placeholder'' for any statement that adheres to the specification given for it, here we only specified that whatever statement that executes there \emph{could} assign to the abstract
location set \rcode{frN} and \emph{could} access \rcode{fpN}.

What we have done by specifying the \emph{abstract execution constraint}, the first three lines in Before and After, is to place an additional restriction on the assignable abstract
location set \rcode{frN} of the AS present in \rcode{n()} stating that \rcode{x} is not an element of \rcode{frN}. As such \rcode{n()} should not be able to alter the value (a reference)
\rcode{x} holds.

We use an assertion to ensure we consider only the refactoring when \rcode{x} is an instance of its intended type.

\begin{figure}[!h]
  \centering
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/before.refinity}
    \vspace{-2mm}
    \caption{Before}
    \label{lst:ExtractVariable-refinity-before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/after.refinity}
    \vspace{-2mm}
    \caption{After}
    \label{lst:ExtractVariable-refinity-after}
  \end{subfigure}\vspace{4mm}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-refinity}
\end{figure}

REFINITY manages to prove automatically that the postcondition holds after abstract execution of both side; here meaning that
\rcode{x} and \rcode{temp} hold the same reference and that any execptions thrown are identical.

One can consider what we have managed to encode and prove a partial success.
Indeed if we remove the constraint on \rcode{x} not being assigned to as a side-effect of executing \rcode{n()}  REFINITY fails to prove our postcondition end up holding.
Yet this is a slightly unnatural encoding if we are to consider concrete instantiations of what we have expressed here.
We do not really intend to encode that return statements must occur at the end as shown, but that from that point onwards the reference \rcode{x} and \rcode{temp} hold
are identical. Thus we manage to encode our desired postcondition, but not capture the desired concrete instantiation with our fragments.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
