Let us consider the Extract Local Variable refactoring seen in lis.~\ref{lst:ExtractVariable-java} which has had dynamic detection of
possible behavioral preservation violations considered in prior work by Eilertsen et al.~\cite{stolz:isolarefa}. Suppose \lstinline[style=smallJava]|n()|
changes the reference \lstinline[style=smallJava]|x| holds and let us rewrite the method calls of \lstinline[style=smallJava]|n()| to show unique
object identities explicitly; before we would have \lstinline[mathescape=true,style=smallJava]|o$_1$.n()| and then
\lstinline[mathescape=true,style=smallJava]|o$_2$.n()| whereas after we would have \lstinline[mathescape=true,style=smallJava]|o$_1$.n()|
and then \lstinline[mathescape=true,style=smallJava]|o$_1$.n()|; in this case if e.g. \lstinline[mathescape=true,style=smallJava]|n()|
simply prints \lstinline[mathescape=true,style=smallJava]|this.toString()| we will observe a difference in the two programs.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{.2\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/before.java}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}{.3\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/after.java}
    \caption{After}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-java}
\end{figure}

The dynamic check for such a change detailed in other work~\ref{stolz:isolarefa} codified the neccessity that the reference \lstinline[style=smallJava]|x|
holds remain unchanged by the introduction of an assertion \lstinline[style=smallJava]|asssert temp == x;| to uncover violations.

In Refinity we encode this condition as seen in lis.~\ref{lst:ExtractVariable-refinity} where we explicitly constrain \lstinline[style=refinity]|n()| and
such that it may not assign to \lstinline[style=refinity]|x|; this is done through the abstract execution constraint specification \lstinline[style=refinity]|\disjoint(x,frN)|
where \lstinline[style=refinity]|frN| specifies the location set \lstinline[style=refinity]|n()| may assign to. Part of the specifciation relating to
ensuring that \lstinline[style=refinity]|x| is an instance of its intended type is omitted (the ellipsis) for brevity. The  postcondition we ask that Refinity
verify is that the returned references of the before and after sides are identical, that excep.
\begin{figure}[!h]
  \centering
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/before.refinity}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/after.refinity}
    \caption{After}
  \end{subfigure}\vspace{1mm}
  \begin{subfigure}[b]{.39\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/method.refinity}
    \caption{Method}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-refinity}
\end{figure}
One can consider Refinity the encoding we have managed to perform and prove in lis.~\ref{lst:ExtractVariable-refinity} a partial success. Indeed if the constraints on
\lstinline[style=refinity]|x| not being assigned to by \lstinline[style=refinity]|n()| is removed Refinity fails to prove that the return values are always identical.
Yet this is a slightly unnatural encoding if we are to consider concrete instatiations of what we have here expressed. We do not really intend to encode that return
statements must occur at the end as shown, but that from that point onwards the reference \lstinline[style=refinity]|x| and \lstinline[style=refinity]|temp| hold
are identical. Thus we manage to encode our desired postcondition, but not capture the desired concrete instantiation with our fragment.
