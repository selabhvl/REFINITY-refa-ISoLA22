Let us consider the Extract Local Variable refactoring seen in Listing~\ref{lst:ExtractVariable-java}.
The example is an instance of a more general case, where preserving the behaviour of the program depends on other parts of the code.
The behaviour of the program changes if the method call \jcode{n()} has access to the attribute \jcode{x} and overwrites it.

Before we would have calls to \jmcode{o$_1$.n()} and then \jmcode{o$_2$.n()} whereas after applying the refactoring we would
have \jmcode{o$_1$.n()} followed by \jmcode{o$_1$.n()}. In this case if e.g. \jcode{n()} simply prints \jcode{this.toString()} we will
observe a difference in the two programs.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{.2\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/before.java}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}{.3\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/after.java}
    \caption{After}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-java}
\end{figure}

The dynamic check for such a change detailed in other work~\cite{stolz:isolarefa} codified the necessity that the reference \jcode{x}
remains unchanged through the introduction of an assertion \jcode{assert temp == x;} to uncover violations after the fact,
which is useful e.g. when checking the refactored code against its suite of unit tests.

In REFINITY one proceeds to verify a refactoring as correct by supplying the code before and after refactoring and supplying a desired precondition and postcondition to relate
the two programs. One essentially asks REFINITY: Given these preconditions does the postcondition hold after abstract execution of these two programs? REFINITY accepts a restricted
subset of Java, the same restrictions present in KeY, with extensions for abstract program fragments; pieces that are ``placeholders'' for concrete Java code.
A proof of correctness in REFINITY is a proof for any concrete Java programs that can be \emph{instantiated} to adhere to the specification given in REFINITY.

The specification facilities for either Java constructs or abstact program fragments are described in the Java Modelling Language (JML) with some extensions.

We describe the refactoring to REFINITY as shown with a left side (Before) in Listing~\ref{lst:ExtractVariable-refinity-before},
a right side (After) in Listing~\ref{lst:ExtractVariable-refinity-after} and a method level context which contains the method we have already shown in Listing~\ref{lst:ExtractVariable-refinity-method}.

Additionally some information is declared in parts of REFINITY's interface that are not shown here:
Free program variables, here \rcode{x}; abstract location sets, here \rcode{frN} and \rcode{fpN}; relevant locations for the before and after code, here empty;
the desired precondition, here empty, and the desired postcondition.

The pre- and postcondition are specified in terms of equations that may relate the effects of the before and after side such as return values, exceptions thrown and any of the relevant locations declared.
In our case we simply specify the postcondition that \rcode{x} returned in Before must be identical to \rcode{temp} returned in After and that any exception thrown must be identical for the two sides.

We use an assertion to ensure we consider only the refactoring when \rcode{x} is an instance of its intended type.
\begin{figure}[!h]
  \centering
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[linerange={2-5},style=refinity]{ExtractVariable/REFINITY/before.refinity}
    \vspace{-2mm}
    \caption{Before}
    \label{lst:ExtractVariable-refinity-before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}[b]{.34\linewidth}
    \lstinputlisting[linerange={2-6},style=refinity]{ExtractVariable/REFINITY/after.refinity}
    \vspace{-2mm}
    \caption{After}
    \label{lst:ExtractVariable-refinity-after}
  \end{subfigure}\vspace{4mm}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-refinity}
\end{figure}
With only the specification as shown in Listing~\ref{lst:ExtractVariable-refinity} REFINITY is unable to prove that \rcode{x} will be identical to \rcode{temp} after AE of both sides.
\oanote*{discuss the open goal if it is simple enough to convey}{Something is missing} and that is to specify that the execution of the abstract statement \rcode{N} cannot interfere with \rcode{x}.
We must introduce a constraint on the frame \rcode{frN} of \rcode(N), namely that it is disjoint from \rcode{x}.
To do so we put an abstract execution constraint \rcode{//@ ae\_constraint \\disjoint(x,frN);} on each side which ensures \rcode{x}
will be assumed not to be in \rcode{frN}.

After the aformentioned change REFINITY manages to automatically prove that the postcondition holds after abstract execution of both sides;
\rcode{x} and \rcode{temp} will hold identical references and any execptions thrown will be identical.

One can consider what we have managed to encode and prove a partial success.
Yet this is a slightly unnatural encoding if we are to consider concrete instantiations of what we have expressed here.
What we would somehow want to express is to have after the first call to \rcode{n()} on each side abstract statements that are related by a substitution of \rcode{x} and \rcode{temp}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
