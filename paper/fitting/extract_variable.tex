Let us consider the Extract Local Variable refactoring seen in lis.~\ref{lst:ExtractVariable-java} which has had dynamic detection
considered~\ref{stolz:isolarefa} for one of its pitfalls. Suppose \lstinline[style=smallJava]|m()| changes the reference
\lstinline[style=smallJava]|x| holds whereas \lstinline[style=smallJava]|n()| does not and let us rewrite the method calls of \lstinline[style=smallJava]|n()| to show unique
object identities explicitly; before we would have \lstinline[mathescape=true,style=smallJava]|o$_1$.n()| and then
\lstinline[mathescape=true,style=smallJava]|o$_2$.n()| whereas after we would have \lstinline[mathescape=true,style=smallJava]|o$_1$.n()|
and then \lstinline[mathescape=true,style=smallJava]|o$_1$.n()|.


\begin{figure}[!htb]
  \centering
  \begin{subfigure}{.2\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/before.java}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}{.3\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/Java/after.java}
    \caption{After}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-java}
\end{figure}

The dynamic check for such a change detailed in other work~\ref{stolz:isolarefa} codified the neccessity that the reference \lstinline[style=smallJava]|x|
holds remain unchanged by the introduction of an assertion \lstinline[style=smallJava]|asssert temp == x;| to uncover violations.

In Refinity we encode this condition as seen in lis.~\ref{lst:ExtractVariable-refinity} where we explicitly constrain \lstinline[style=refinity]|m()| and
\lstinline[style=refinity]|n()| such that they may not assign to \lstinline[style=refinity]|x|; this is done through the abstract execution constraint
specification that contains the conjunction of \lstinline[style=refinity]|\disjoint(x,frM)| and \lstinline[style=refinity]|\disjoint(x,frN)| where respectively
\lstinline[style=refinity]|frM| and \lstinline[style=refinity]|frN| specify the location sets \lstinline[style=refinity]|m()| and \lstinline[style=refinity]|n()| may
assign to. The specification of the methods and the location sets they assign to and access are omitted here for brevity, as is part of the specification shown
with the ellipsis that relates to ensuring that \lstinline[style=refinity]|x| is an instance of its intended type. The specified postcondition here is that the
return reference of the before and after are identical.


\begin{figure}[!htb]
  \centering
  \begin{subfigure}{.4\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/before.refinity}
    \caption{Before}
  \end{subfigure}\hspace{1cm}
  \begin{subfigure}{.4\linewidth}
    \lstinputlisting[style=refinity]{ExtractVariable/REFINITY/after.refinity}
    \caption{After}
  \end{subfigure}
\captionof{lstlisting}{Extract Local Variable}
\label{lst:ExtractVariable-refinity}
\end{figure}

One can consider Refinity the encoding we have managed to perform and prove in lis.~\ref{lst:ExtractVariable-refinity} a partial success. Indeed if the constraints on
\lstinline[style=refinity]|x| not being assigned to by \lstinline[style=refinity]|m()| and \lstinline[style=refinity]|n()| are removed Refinity fails to prove that
the return values are always identical. Yet this is a slightly unnatural encoding if we are to consider concrete instatiations of what we have here expressed. We do
not really intend to encode that return statements must occur at the end as shown, but that from that point onwards the reference \lstinline[style=refinity]|x| and
\lstinline[style=refinity]|temp| hold are identical. Thus we manage to encode our condition, but not capture the desired concrete instantiation.
