Another area of interest for equivalence is replacing one data structure with another,
e.g.\ Fowler's \rname{Replace Array with Object}~\cite[p.186]{fowler:refactoring} or \rname{Replace Primitive with Object}~\cite{fowler:refactoring2nd}.
As an example, in the following we look at a piece of code where an array is replaced with an object (or vice versa).
Again, from the strict default perspective of ``equal return values, equal heaps'', any two programs using the data structures are obviously not equal.
Encoding observability through traces as per the previous section will obviously solve this issue.
A new challenge arises when both programs use different or disjoint sets of operations, i.e.\ we have different alphabets for their trace languages.

\input{limits/replace_array_with_object}


%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: "main"
%%% End:
