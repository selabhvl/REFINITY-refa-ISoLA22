\documentclass[runningheads]{llncs}


%%%%%%%%%%%%%%%%%
% USED PACKAGES %
%%%%%%%%%%%%%%%%%
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{color}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\input{listingssetup}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{subcaption}
\usepackage{xcolor}
\captionsetup{compatibility=false}
\captionsetup[subfigure]{justification=centering}
%%%%%%%%%%%%%%%%%%%%%%%% fixme
\usepackage[draft,silent]{fixme}
\fxsetup{theme=color,mode=multiuser}
\definecolor{fxtarget}{rgb}{0.8000,0.0000,0.0000}
\FXRegisterAuthor{todo}{TODO}{TODO}
\FXRegisterAuthor{vp}{VP}{\color{violet}\scriptsize{\bf VP}}
\FXRegisterAuthor{vs}{VS}{\color{cyan}\scriptsize{\bf VS}}
\FXRegisterAuthor{oa}{OA}{\color{blue}\scriptsize{\bf OA}}
\FXRegisterAuthor{ek}{EK}{\color{brown}\scriptsize{\bf EK}}
%%%%%%%%%%%%%%%%%%%%%%%% fixme

\input{defs}

\pagestyle{plain}

\title{Towards practical abstract execution}
\author{Ole J{\o}rgen Abusdal\inst{1} \and Eduard Kamburjan\inst{2} \and Violet Ka I Pun\inst{1} \and Volker Stolz\inst{1}}

\institute{%
Western Norway University of Applied Sciences, Norway\\
\email{\{ojab,vpu,vsto\}@hvl.no}
\and University of Oslo, Norway\\
\email{eduard@ifi.uio.no}
}

% What we want
% Talk about the renaming issue (identify in which cases it's interesting)
% Talk about relational verification
% For NPEs:
%  1. several ways to specify whether two objs. are equiv., need to decide that equiv!
%  2. Observables, if observ. are event-like then we can do it a history variable (as in KeY-ABS) otherwise we need symbolic-traces
% 3. For e.g. the array coordinate problem we need relational invariants in addition to relational postconditions (see mathias paper?)
% 


\begin{document}

\maketitle

\begin{abstract}
Relational verification through dynamic logic is a promising approach for verification of object oriented programs.
Recent advances from symbolic to abstract executions have enabled reasoning about incomplete/abstract versions of such programs.
This has proven fruitful in the exploration of correctness of refactorings primarily related to code blocks in Java.
In this paper we explore further types of equivalent transformations and refactorings and discuss the challenges that still
need to be overcome for full round-trip correctness of refactorings in object-oriented languages.
\end{abstract}

\section{Introduction}
\input{intro}

\section{Preliminaries: Abstract Execution}\label{sec:prelim}
\input{preliminaries}

\input{fitting/extract_variable}

\section{Challenges}\label{sec:challenges}
In this section we explore the possibilities of \Refinity{} beyond the original work.
In particular, we are interested in moving away from statement-based refactorings to more complex changes that also affect the structure of the code.
The first new refactoring, Hide Delegate, harnesses Java inner classes to express the desired behaviour of \Refinity{} in a straight-forward manner
and KeY automatically completes the proof once the right preconditions are identified.

After that, we present a refactoring that is related to Dead Code Elimination.
This requires introduction of additional constructs for object-construction within KeY,
which are then harnessed in tactlets that express that certain non-identical heaps guarantee equivalent behaviour.

We continue our wishlist for further flexibility in expressing equivalent program behaviour based on the execution history of user-defined observable actions,
and finally discuss challenges related to expressing equivalence in the face of different data types.

\input{fitting/hide_delegate}
\subsection{Object creation}\label{sec:objectcreation}
\input{objectcreation}

\subsection{Trace properties}\label{sec:traces}
\input{traces}

\subsection{Relational invariants}\label{sec:relational}
\input{relational}

\section{Discussion}\label{sec:discussion}
\input{discussion}

\section{Related Work}\label{sec:related}

\begin{itemize}
\item formal proofs of correctness for OO program optimisation
\item formal proofs of OO refactoring
\item check Dominic's thesis and papers for the relevant related work
\item important: correctness on actual Java, not something which looks like Java
\item also: correctness with respect to OO features
\end{itemize}

\input{related}

\section{Conclusion}\label{sec:conclusion}

We have presented two new encodings of refactorings (\rname{Extract Local Variable} and \rname{Hide Delegate}) and their necessary preconditions (constraints) for them to be behaviour-preserving for \Refinity{}.
\Refinity{} has syntactical constructs that capture abstract program executions, for which the KeY system,
an automated theorem prover for JavaDL, succeeds in proving the refactorings as correct (equal) wrt.\ to the Java semantics without user interaction.

The \rname{Hide Delegate} refactoring departs from statement-based refactorings and considers changes involving multiple classes and requires us to consider the first subtle difference between equivalent-yet-not-equal objects in the form of equivalent exceptions and how we need to explicitly address this in the post-condition of the proof-obligation.
This also allows us to make a contribution through further taclets that capture some indistinguishable programs that only differ in placement of objects on the heap.

We discuss in how far \Refinity{} could be used to capture other refactorings, broadening our investigation into the underlying notion of sometimes use-case specific \textit{equivalent behaviour}.
For example, while traces over observable behaviour could be explicitly encoded and checked against each other as return values in \Refinity{}, a more general process-algebra inspired approach of execution histories for abstract executions would avoid confounding the original program logic with scaffolding to achieve an encoding without having to extend the tool.
We also point out the difficulties due to a naming issue in the current encoding from Refinity to KeY proof-obligations for refactorings that change the class hierarchies or in general attempt to relate behaviour across different types.

\paragraph{Future Work.} 
To investigate the discussed problems with refactoring using AE wrt.\ trace properties, we are currently implementing AE for BPL in the Crowbar tool~\cite{crowbar} as a starting point, a symbolic execution engine to prototype behavioral symbolic execution.

We are also working on contributing further encodings of common refactorings that can already now be handled by \Refinity{}.
In addition, we are particularly interested in additional taclets for KeY that would enable automation of proofs
that currently are stuck on the explicit symbolic encoding of program state although it would be indistinguishable from equivalent states in pratice.
The latter is of relevance e.g. for proving common optimizations as in our \rname{Dead Code Elimination} example.

\subsubsection*{Acknowledgements}
This work was partially supported by the Research Council of Norway via \texttt{SIRIUS} (237898), \texttt{PeTWIN} (294600) and \texttt{CROFLOW} (326249).
%\input{conclusion}

% \section{Leftovers}
% \textit{Use if space/time/useful.}
% \subsection{Remove assignment to parameter}
% \input{limits/remove_assignment_to_parameter}

\bibliographystyle{splncs04}
\bibliography{refs}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: t
%%% End:
