
Relational verification through dynamic logic is a promising approach for verification of refactorings in object oriented programs.
Recent advances from symbolic to Abstract Execution (AE)~\cite{DBLP:conf/fm/SteinhofelH19} have enabled reasoning about incomplete/abstract versions of such programs.
This has proven fruitful in the exploration of correctness of refactorings primarily related to code blocks in Java:
%In this paper we explore further types of equivalent transformations and refactorings and discuss the challenges that still need to be overcome for full round-trip correctness of refactorings in object-oriented languages.
%
AE introduces abstract statements (and expressions), which act as named and specified placeholders for statements of the host language.
A refactoring proof is a relational verification proof that compares two programs which can have abstract program elements.
Consider relating ``\jmcode{if ($E_{bool}$) \{$S_1$;\} else \{$S_2;$\}}'' and ``\jmcode{if(!$E_{\mathit{boolean}}$) \{$S_2$;return;\} $S_1$;}'' where
$E_{\mathit{boolean}}$ represents an arbitrary boolean expression, $S_1$ and $S_2$ represent arbitrary statements.
One of the programs represents the schema of the code before the refactoring, and the other one the code afterwards, with respect to some relational post-condition that defines the notion of \emph{program equivalence}.


\paragraph{Challenges.}
More complex refactorings need more elaborate specification and verification techniques for relational verification. 
The reason is that the programs surrounding the abstract statements, as well as the notion of equivalence, become more involved.
This holds for both structure and behaviour.
\Refinity{} \cite{steinhoefel:ae}, the tool supporting verification on top of the KeY system, an automated theorem prover for Java~\cite{DBLP:conf/aplas/Steinhofel20},
has been primarily designed to verify the correctness of refactorings that are based on moving code within a method, or on extracting some statements into their own method (i.e., the \rname{Extract Method} refactoring).
However, refactorings are not limited to single methods or statement-blocks, but may also restructure classes and data structures \cite{fowler:refactoring}.
We investigate the \rname{Hide Delegate} refactoring that moves code between classes and show how it can be encoded in \Refinity{}.


As for behaviour, we discuss the interpretation of \textit{equivalence} from the perspective of the user and how to encode this --- for example, if the surrounding programs throw exceptions, under which conditions are the exceptions considered equivalent?

We illustrate that this issue goes beyond exceptions:
As they are just objects, there are several possible choices for when newly created objects are considered equal in relational verification using dynamic logic, 
first investigated by Beckert et al.~\cite{DBLP:conf/lopstr/BeckertBKSSU13}.



For exceptions and object creation, we describe several possibilities when newly created objects (resp.\ thrown exceptions) are considered equal
and how this information can be used in dynamic logic proofs. The different possibilities are implemented as different rule sets and do not have to be encoded in the relational post-condition.
This reduces the size of the required specification, which is an advantage, since it is a notorious bottleneck in formal verification~\cite{DBLP:journals/corr/abs-1211-6186,DBLP:series/lncs/HahnleH19}.


Furthermore, we discuss the necessary extensions needed to prove equivalent behaviour where one data structure is replaced by another, e.g., an array or any primitive type by a class.
Here, the main challenge lies in the encoding that the structures are used correctly throughout the execution.
This could, for example, be handled by coupled invariants~\cite{DBLP:conf/birthday/BeckertU18}, whose connection to AE is yet unclear. 
Lastly, we discuss the challenge to apply AE to novel specification approaches for \emph{traces} which aim to simplify the specification of temporal properties for expressive properties, but whose use for relational verification is unexplored.

\paragraph{Contributions and Structure.}
Our contributions are firstly an investigation into the necessary side conditions to be able to proof of the correctness of the \rname{Extract Local Variable}- and \rname{Hide Delegate} refactorings, extending the collection of proven refactorings.
The latter is a refactoring beyond code motion within a method and highlights the interaction of AE with general relational verification challenges.
Secondly, we discuss possible extensions that would be required to address further refactorings with AE.

%This paper is structured as follows. 
We first describe AE and relational verification using the \rname{Extract Local Variable} refactoring in Sec.~\ref{sec:prelim}, before we show necessary conditions for the \rname{Hide Delegate} refactoring to be correct  and then discuss the challenges for AE in Sec.~\ref{sec:challenges}. Sec.~\ref{sec:discussion} discusses our results and Sec.~\ref{sec:related} gives the related work. Lastly, Sec.~\ref{sec:conclusion} concludes.



%This paper is structured as follows: we first provide an overview on abstract executions, the main vehicle for correctness- and equivalence proofs, and their use in REFINITY.
%Next, we provide an encoding of the Hide Delegating refactoring for REFINITY that moves away from statement-based refactorings to object-oriented refactorings in Section \ref{sec:hideDelegate}.
%After that in Section \ref{sec:challenges}, we explore (and address, where possible) \vsnote*{Not really limitations...better word?}{limitations} in REFINITY that we have discovered by investigating further refactorings.
%Our main goal is to extend the notion of \textit{equal} programs to \textit{equivalent} programs, e.g. by replacing data types.
%\vsnote{Mention possible application to optimizations already in intro? Probably.}
%We conclude with a discussion in Section \ref{sec:discussion} on the feasibility of necessary developments \vsnote*{esp. if we want to use histories in subsequent proofs.}{and their dependencies}.
% VS: This will then be included in the section above:
% Next we discuss issues related to formally correct and constructive handling of object creation to be able to express useful notions of equivalence in Section \ref{sec:objectcreation}.
% Section \ref{sec:trace} moves away from only heap-related equivalence and discusses tracking equivalent observable behaviour in a relational framework.
% The final challenge are relational invariants that we discuss in Section \ref{sec:relinv} which are required to track equivalent, yet structurally different representation of data types.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
