Similar or other approaches to formal verification of refactorings can be found in work by
Garrido et al. \cite{garrido2006formal} who formalize \rname{Push Down Method},
\rname{Pull Up Field} and \rname{Rename Temporary} using an executable
Java formal semantics in Maude and give partially mechanised proofs for the two former.

Long Quan et al. \cite{DBLP:conf/isola/QuanQL08} formulate refactorings as refinement
laws in the calculus of refinement of component and object-oriented systems (rCOS),
focusing on correctness proofs of refactoring rules themselves.
They did not have the benefit of any tool support, but similarly were able to describe
refactorings on schematic programs.
Statement level refactorings as well as refactorings that transform class hierarchies are considered.

While KeY and \Refinity{} are unique for their relational verification capacity for
schematic programs (or abstract programs) they are limited in power for verification
of concrete programs relying much more on manual specification or interaction \cite{DBLP:conf/aplas/Steinhofel20}
than tools like LLRÃªve \cite{DBLP:journals/jar/KieferKU18} or SymDiff \cite{DBLP:conf/cav/LahiriHKR12}
which offer more automation for concrete programs.

Peter M{\"u}ller et al. \cite{DBLP:series/natosec/0001SS17} present a verification infrastructure whose intermediate language supports
an expressive permission model natively, with tool support including two back-end verifiers: one based on
symbolic execution and one on verification condition generation, an inference tool based on abstract
interpretation reportedly under development.

Stolz, Pun and Gheyi investigate how well-known refactorings interact with concurrency in Active Object languages~\cite{DBLP:conf/isola/StolzPG20}.
Findings show that refactorings that are straight-forward in Java are not necessarily so under the concurrency model considered and identify key
program transformations that may cause interactions.
In contrast to their work, \Refinity{} and its foundation KeY strictly consider sequential Java programs,
but they already explore the notion of equivalent executions in their formal considerations of syntactically different, but overlapping, programs.

Eilertsen, Stolz and Bagge demonstrate a technique of introducing runtime checks in Java for two refactorings \rname{Extract And Move Method} and
\rname{Extract Local Variable}~\cite{stolz:isolarefa}. The technique in combination with testing can detect changed behavior and allow identification
of which refactoring step introduced the change the deviant behavior.
Our proof of correctness of \rname{Extract Local Variable} in \Refinity{} is inspired by their technique.


Schaefer et al. develop microrefactorings that can be composed to specify several refactorings in a concise manner~\cite{Schafer-OOPSLA-2010}.
They use an infrastructure to preserve correct name binding in refactorings.

Soares et al. \cite{Soares-IEEE-2010} describe and evaluate SafeRefactor - a tool that given a program input and a refactoring to apply can automatically generate testcases to detect behavioural changes.
It would be interesting to adapt SafeRefactor to do deal with REFINITY's abstract programs, and generate test cases for the instances where \Refinity{} fails to prove a refactoring.
These could then be run against concrete refactored programs.
\vsnote{@ALL: Rephrased. Semantic check please :-)}

Dovland et al. \cite{dovland:adaptableclass2015} propose a proof system that allows
incrementally reasoning about adaptable class hierarchies, based on
lazy behavioural subtyping, for 
an object-oriented kernel language similar to Featherweight Java. The
proof system avoids reverifying methods that are not modified
explicitly by the class adaptation.
We are unaware whether the incremental reasoning broached for the proof system has a counterpart in KeY and \Refinity{}, but
the latter allows for modularity in proof and verification which may achieve a similar result.


%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: "main"
%%% End:
