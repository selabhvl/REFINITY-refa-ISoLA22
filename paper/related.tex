Similar or other approaches to formal verification of refactorings can be found in work by
Garrido et. al. \cite{garrido2006formal} who formalize \emph{``Push Down Method''},
\emph{``Pull Up Field''} and \emph{``Rename Temporary''} using an executable
Java formal semantics in Maude and give partially mechanized proofs for the two former.

Long Quan et. al. \cite{DBLP:conf/isola/QuanQL08} formulate refactorings as refinement
laws in the calculus of refinement of component and object-oriented systems (rCOS),
focusing on correctnes proofs of refactoring rules themselves.

While KeY and REFINITY is unique for its relational verification capacity for
schematic programs (or abstract programs) it is limited in power for verification
of concrete programs relying much more on manual specification or interaction \cite{DBLP:conf/aplas/Steinhofel20}
than tools like LLRÃªve \cite{DBLP:journals/jar/KieferKU18} or SymDiff \cite{DBLP:conf/cav/LahiriHKR12}
which offer more automation for concrete programs.

\oanote*{sort of in the same ballpark}{
Peter M{\"u}ller et. al, Viper,  presents a verification infrastructure whose intermediate language supports
an expressive permission model natively, with tool support including two back-end verifiers: one based on
symbolic execution,one on verification condition generation; an inference tool based on abstract
interpretion is currently under development. \cite{DBLP:series/natosec/0001SS17}}

Stolz, Ka I Pun and Gheyi, investigate how well-known refactorings interact with concurrency in Active Object languages \cite{DBLP:conf/isola/StolzPG20}.
Findings show that refactorings that are straight-forward in Java are not necessarily so under the concurrency model considered and identify key
program transformations that may cause interactions.
REFINITY and its foundation KeY strictly considers sequential Java programs.



//TODO look in rohit isola and anna refactoring papers

\cite{dovland:adaptableclass2015} proposes a proof system that allows
incrementally reasoning about adaptable class hiearachies, based on
lazy behavioural subtyping, for 
an object-oriented kernel language similar to Featherweight Java.  The
proof system avoids reverifying methods that are not modified
explicitly by the class adaptation.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
