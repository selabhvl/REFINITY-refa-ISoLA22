Similar or other approaches to formal verification of refactorings can be found in work by
Garrido et al. \cite{garrido2006formal} who formalize \rname{``Push Down Method''},
\rname{``Pull Up Field''} and \rname{``Rename Temporary''} using an executable
Java formal semantics in Maude and give partially mechanized proofs for the two former.

Long Quan et al. \cite{DBLP:conf/isola/QuanQL08} formulate refactorings as refinement
laws in the calculus of refinement of component and object-oriented systems (rCOS),
focusing on correctness proofs of refactoring rules themselves.

While KeY and \Refinity{} are unique for their relational verification capacity for
schematic programs (or abstract programs) they are limited in power for verification
of concrete programs relying much more on manual specification or interaction \cite{DBLP:conf/aplas/Steinhofel20}
than tools like LLRÃªve \cite{DBLP:journals/jar/KieferKU18} or SymDiff \cite{DBLP:conf/cav/LahiriHKR12}
which offer more automation for concrete programs.

Peter M{\"u}ller et. al present a verification infrastructure whose intermediate language supports
an expressive permission model natively, with tool support including two back-end verifiers: one based on
symbolic execution,one on verification condition generation; an inference tool based on abstract
interpretation is \vsnote*{2009?}{currently} under development. \cite{DBLP:series/natosec/0001SS17}

Stolz, Pun and Gheyi investigate how well-known refactorings interact with concurrency in Active Object languages~\cite{DBLP:conf/isola/StolzPG20}.
Findings show that refactorings that are straight-forward in Java are not necessarily so under the concurrency model considered and identify key
program transformations that may cause interactions.
\Refinity{} and its foundation KeY strictly considers sequential Java programs.
\vsnote{@Ole: do you think the Festschrift is related?}

Eilertsen, Stolz and Bagge demonstrate a technique of introducing runtime checks in Java for two refactorings \rname{Extract And Move Method} and
\rname{Extract Local Variable}~\cite{stolz:isolarefa}. The technique in combination with testing can detect changed behavior and allow identification
of which refactoring step introduced the change the deviant behavior.
Our proof of correctness of \rname{Extract Local Variable} in \Refinity{} is inspired by the technique employed by Eilertsen et al.


Schaefer et al. develop microrefactorings that compose to specify several refactorings in a concise manner~\cite{Schafer-OOPSLA-2010}.
They tackle name binding issues that arise during transformations and make use of an infrastructure to preserve correct name binding in refactorings.
\oanote{double check}{Proof of general correctness is not provided, instead testing is performed.}


Soares et al. describe and evaluate SafeRefactor - a tool that given a program input and a refactoring to apply can automatically generate testcases to detect behavioral changes~\cite{Soares-IEEE-2010}.
\oanote{should actually try this for some case, or look at an example of Dom's}{In the instances where \Refinity{} fails to prove a refactoring it can generate testcases relating to the goals left open for the failed proof.}


Dovland et al. \cite{dovland:adaptableclass2015} propose a proof system that allows
incrementally reasoning about adaptable class hierarchies, based on
lazy behavioural subtyping, for 
an object-oriented kernel language similar to Featherweight Java.  The
proof system avoids reverifying methods that are not modified
explicitly by the class adaptation.
\oanote*{paper is a challenge to read, is this correct?}{KeY and \Refinity{} allows for modularity in proof and specification, but not the incremental reasoning broached
for the proof system for adaptable class hierarchies.}



%%% Local Variables:
%%% mode: latex
%%% eval: (auto-fill-mode -1)
%%% TeX-master: "main"
%%% End:
